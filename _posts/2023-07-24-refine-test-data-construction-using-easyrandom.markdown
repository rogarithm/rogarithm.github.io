---
layout: post
title: "EasyMock으로 테스트 데이터 생성 방식 개선하기"
date: 2023-07-24 00:54:58 +0900
categories: testing
---
* table of contents
{:toc}

&nbsp;

### 테스트 코드도 유지보수가 필요하다

이미 구현한 기능이더라도 더 다듬을 부분이 있고, 새로 기능을 만들면서 기존 설계를 바꾸기도 한다. 테스트는 이런 크고 작은 변경 시에 실수할 위험을 줄여준다. 하지만 프로그램을 만들면서 테스트를 깨끗하게 유지하지 않으면 어느새 복잡해져서 이런 장점을 누리기 어려워진다. 그래서 나는 실제 코드와 마찬가지로 테스트 코드를 여러 번 다듬고, 어떻게 다듬어야 할지를 고민한다.

그간 여러 방식으로 테스트를 다듬었지만, '더 나은 개선 방안은 없을까' 하는 생각이 머릿속을 멤돌았다. 그러던 중 예전 프로젝트에서 받은 코드 리뷰 중 들었던 EasyRandom이 떠올랐다.

![EasyRandom](/images/easy-random/easy-random-icon.png)


EasyRandom은 테스트 데이터 생성에 쓸 수 있는 라이브러리다. 원하는 타입에 임의의 필드값을 넣어 인스턴스를 만들 수 있게 도와준다. 테스트 데이터를 만들 때 필드마다 값을 집어넣을 필요가 없어진다는 얘기다. 이제까지 모든 테스트 데이터를 하드코딩해서 만들었는데, 필드마다 어떤 값을 넣어야할지 고민하고, 테스트마다 테스트 데이터를 만들어야 하는 점이 불편하게 느껴졌다. 기존 방식을 EasyRandom으로 바꾸면 이런 점을 개선할 수 있지 않을까 싶었다. 다만 기존에 테스트 데이터를 만드는 방식을 바꿀 수 있는지 확인할 필요가 있었다. 그래서 기존에 만들어져 있던 테스트에서 테스트 데이터를 어떻게 쓰고 있는지, 생성 방식을 바꿔도 괜찮은지 알아보기로 했다.

&nbsp;

### 크게 단위 테스트와 통합 테스트로 나눠서 테스트의 목적에 하드코딩이 꼭 필요한지 생각해봤다.

#### 단위 테스트에서 하드코딩을 쓰지 않아도 괜찮을까?

실제 환경으로부터 격리해 실행하는 단위 테스트는 먼저 의존 객체를 모의 객체로 만들어서 어떻게 동작할지 정의한다. 만든 테이터는 이런 의존 객체의 입력으로 쓰여서 모의 객체가 정의한 행동을 할 때 테스트 대상 객체가 생각한 대로 동작하는지 확인한다. 데이터의 각 필드에는 대부분 그 필드에 들어갈만한 값을 생각해서 집어넣었다. 하지만 모의 객체의 동작을 정의할 때, 원하는 동작을 하게 할 데이터를 정할 수 있기 때문에 테스트 데이터가 의존 객체에 정의한 동작을 실제로 일으키는 값이 아니더라도 테스트를 성공하게 할 수 있다. 테스트용 DB와 서비스용 DB가 분리되어 있어서 두 DB에 저장된 데이터가 서로 다른 경우 등을 생각해보면 하드코딩했던 값을 해당 동작을 실제로 일으키는 값이라고 보는 것도 애매하다. 따라서 하드코딩한 값이라고 할지라도 실제 애플리케이션이 동작하는 환경에서 그 동작을 일으키는 값이라기보다는, 테스트 환경 안에서만 유효한 값이라고 보는 게 맞는 것 같다. 하드코딩하더라도 실제 상황을 그대로 반영하는 것이 어렵고, 이마저도 생각해내는 데 시간이 걸린다. 여기에 더해, 의미있는 값을 넣으려고 고민한 시간이 무색하게 이런 고민이 들어간 코드가 테스트를 읽는 걸 쉽게 해주지는 않았다. 이런 점들을 고려해보니 단위 테스트는 테스트 데이터에 어떤 값이 들어갈지 고려하지 않고, 테스트 대상 객체의 동작 확인에 신경쓰도록 바꿔도 괜찮겠다고 결론내렸다.

&nbsp;

#### 통합 테스트에서 하드코딩을 쓰지 않아도 괜찮을까?

통합 테스트는 실제 의존 객체가 잘 협력하는지를 확인한다. 이 범위의 테스트에서는 실제 환경과 연결해서 실행하므로 테스트 데이터의 필드값은 의미가 있는 값이어야 한다. 여기서 의미가 있다는 건, 이를테면 도메인 모델의 각 필드에 정의한 유효성 조건을 만족하는 걸 뜻한다. 때문에 테스트 데이터를 임의의 값으로 만들 경우, 데이터 값이 실제 환경에 설정한 조건에 맞지 않으면 테스트가 실패할 수 있다. 따라서 테스트 데이터의 값은 테스트로 확인하고자 하는 상황을 일으키는 값이어야 한다.

그렇다면 통합 테스트에서는 EasyRandom을 쓰지 않고 하드코딩으로 테스트 데이터를 만드는 것이 나을까? 그렇지 않다고 생각한다. 왜냐면 하드코딩해야 할 필드 외에 임의값을 가져도 상관없는 필드도 있으며, 이런 필드값을 만드는 것도 EasyRandom이 도와줄 수 있기 때문이다. 하드코딩할 필드도 일정한 범위나 논리를 만족하는 값을 필요로 하고, 이런 조건을 EasyRandom을 써서 매개변수화할 수 있다. 따라서 통합 테스트에서도 EasyRandom을 이용할 수 있겠다고 결론내렸다.

&nbsp;

### 어떻게 적용할까?

#### 특정 값일 필요 없는 테스트 데이터 하드코딩

EasyRandom 인스턴스를 하나 만들고, 만들고 싶은 데이터의 타입을 인자로 해서 nextObject() 메서드를 호출하면 해당 타입의 각 필드별로 타입에 맞는 값이 채워진 테스트 데이터를 생성해준다. 하드코딩으로 값을 설정해주던 코드를 이 코드로 바꿔준다.

&nbsp;

#### 특정 값이어야 하는 테스트 데이터 하드코딩

스프링 애플리케이션 컨텍스트를 띄우는 통합 테스트는 실제 의존 객체를 가져오기 때문에, 테스트 데이터가 임의의 값을 가지면 테스트가 실패할 수 있다. 따라서 테스트 데이터의 값은 테스트로 확인하고자 하는 상황을 일으키는 값이어야 한다.
EasyRandom에서 제공하는 EasyRandomParameter 타입 객체를 만들어서 써먹을 수 있다. EasyRandomParameter 객체는 1) 어떤 필드에 2) 어떤 조건을 갖는 값을 반환하게 할 것인지를 입력해 만들 수 있다. 이 중 값을 반환하게 하는 Randomizer<T> 타입은 함수형 인터페이스이기 때문에 람다식으로 조금 더 간소화할 수 있다.

&nbsp;

### 결론

- 테스트 데이터 이름을 지을 필요가 줄어들었다
- 검증 로직을 단순화할 수 있게 되었다
